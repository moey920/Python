# 정규표현식

- 복잡한 문자열을 처리할 때 사용하는 도구
- 특정 프로그래밍 언어에 종속된 문법을 가진 것이 아니라 문자열을 처리하는 곳이라면 폭넓게 사용 가능한 도구
- 파이썬의 기본 모듈 중 re모듈이 정규표현식을 지원

### 정규표현식이 없다면?

> 보안을 위해 고객 정보 중 전화번호 가운데 자리의 숫자는 * 문자로 변경하세요
```
text = '''
Elice 123456-1234567 010-1234-5678
Cheshire 345678-678901 01098765432
'''
```
    이 문제를 정규식을 사용하지 않고 풀려면 매우 복잡하게 풀어야 합니다.

    - 전체 텍스트를 공백 문자를 기준으로 나눈다.
    - 나누어진 문자열이 전화번호 형식인지 점검한다.
    - 전화번호를 다시 나누어 가운데 자리의 숫자를 *로 변환한다.
    - 나눈 문자열을 다시 합쳐 전화번호를 완성한다.

### 정규표현식을 이용한다면?

> 원하는 형식의 문자열을 검색할 때 메타문자와 수량자 등 다양한 패턴을 사용하여 매치하고, 
그룹핑을 이용하여 원하는 부분만 골라내고 re모듈의 메서드로 문자열을 수정할 수도 있다.

## 정규식 객체 - 복잡하고 긴 정규식을 여러번 사용할 때 유용

```
import re

text = "abcdefg"

pattern = re.compile("e")

print("정규식 객체의 자료형 : ", type(pattern))

print("정규식 객체 사용하는 경우 : ", pattern.findall(text))

print("객체를 사용하지 않는 경우 : ", re.findall("e", text))
```

> ```re.compile()``` 함수는 문자열 패턴을 컴파일하여 정규식 객체를 반환합니다.

- 어떤 정규식을 코드 내에서 여러 번 사용하고자 할 때 re.compile() 함수로 정규식 객체를 만들어 사용합니다.
- re 모듈의 함수는 re클래스의 함수도 있지만, 정규식 객체에서 호출하기도 합니다.
- 10행에서는 pattern 변수의 findall 함수를 호출하고, 12행에서는 re 모듈의 findall 함수를 호출합니다.
- 함수의 인자도 10행에서는 1개, 12행에서는 2개로 각각 다르다, 그러나 결과값은 동일하다.
- 이처럼 re.compile() 함수는 정의한 정규표현식을 여러 번 사용할 때 주로 이용

## re 모듈의 대표적인 함수

### 정규식 검사 함수

> 문자열에 대해 정규식으로 검사하는 함수는 대표적으로 re.match(), re.search(), re.findall(), re.finditer() 이렇게 4가지가 있다.

| 함수 이름 | 기능 |
|:---:|:---:|
| re.match(pattern, string)	| **string** **시작 부분부터** 패턴이 존재하는지 검사하여 **MatchObject**를 반환함. |
| re.search(pattern, string) | **string** 전체에서 **pattern**이 존재하는지 검사하여 **MatchObject**를 반환함. |
| re.findall(pattern, string) | **string** 전체에서 패턴과 매치되는 모든 경우를 찾아 **list**로 반환함. |
| re.finditer(pattern, string) | **string** 전체에서 패턴과 일치하는 결과에 대한 **iterater** 객체를 반환함. |

### 문자열 수정 함수

> re 모듈에는 패턴과 매치된 문자열을 찾아줄 뿐만 아니라, 편집할 수 있는 함수들도 존재

| 함수 이름 | 기능 |
|:---:|:---:|
| re.sub(pattern, repl, string)	| **string** 에서 **pattern과 매칭**되는 부분을 **repl로 수정**한 문자열을 반환함. |
| re.subn(pattern, repl, string) | ```re.sub()```과 동일하지만, 함수의 결과를 ```(결과 문자열, 교체 횟수)```꼴의 튜플로 반환함. |

#### 파이썬 정규표현식 공식 문서 

> <https://docs.python.org/3/library/re.html>

## 정규식 메타 문자

> 메타 문자 : 특정한 문자 혹은 계열을 표현하는 약속된 기호 입니다. 메타 문자를 이용하면 특정한 규칙을 가진 여러 단어를 짧게 압축할 수 있어 편리

### 메타 문자의 구성

| 메타 문자 | 의미 | 예시 |
|:---:|:---:|:---:|
| ^	| 문자열의 시작 | ```^www```는 문자열의 맨 처음에 ```www```가 오는 경우에 매치합니다. |
| $	| 문자열의 끝 | ```.com$```은 문자열의 맨 끝에 ```.com```이 오는 경우에 매치합니다. |
| \| | or 조건식 | 여러 가지 중 하나와 일치하면 매치합니다. `Apple |
| [] | 문자 클래스 | 대괄호 [] 안에 들어있는 문자 중 하나라도 일치하면 매치합니다. [abc]는 ‘a,b,c’ 중 하나와 매칭됩니다. [0-9],[a-zA-Z]등 |
| \d | 숫자를 나타냅니다. | |
| \D | 숫자가 아닌 모든 문자를 나타냅니다. | |
| \w | 알파벳 대소문자, 숫자, 밑줄(_)을 나타냅니다.	| ```[^A-Za-z0-9_]```와 같은 의미이다. |
| \W | \w에 해당되지 않는 문자들을 나타냅니다. | 특수문자 등 |
| \s | 공백, 탭 문자와 매칭됩니다. | ```\t : 가로 탭 문자, \n : 개행 문자, \v : 세로 탭 문자, \f : 용지 넘김 문자, \r : 캐리지 리턴 문자``` |
| \S | \s에 매칭되지 않는 모든 문자를 나타냅니다. | |
| \n | 개행 문자를 나타냅니다. | |
| \	| 이스케이프용 문자. 특별한 의미를 나타내는 기호를 문자 그대로 나타내려고 할 때 사용합니다. | 문자열 내에서 ```$```문자를 찾기 위해서는 ```\$```와 같이 나타내어야 합니다. |
| .	| 모든 문자와 대응되는 기호입니다. | [] 대괄호 속의 .은 마침표 문자 그대로를 나타내므로 유의하셔야 합니다. |
| (?i)	| 패턴이 대소문자를 무시하게한다. | 플래그가 위치에 상관 없이 패턴 내에 포함되어있기만 하면, 해당 패턴은 대소문자를 무시하게 됩니다. ```(?i)apple``` |

## 수량자

> 수량자 : 동일한 글자나 패턴이 반복될 때, 그대로 정규표현식을 만들고자 하면 상당히 불편하다.
\d와 \w를 이용하면 각각 숫자와 문자를 한 글자씩 매칭해주는데, 이어지는 문자를 패턴으로 만들어, 단어 단위로 매칭하고 싶을 때엔 상당히 불편하다. 이런 상황에서 수량자를 활용한다.

| 수량자 | 의미 | 예시 |
|:---:|:---:|:---:|
| *	| 0개 이상 | ```elice*```는 “elic”, “elice”, “elicee”, “eliceee…eee”와 매칭됩니다. |
| +	| 1개 이상 | *와는 달리, 적어도 해당 문자가 1개 이상이어야 매칭됩니다. |
| ?	| 0개 또는 1개 | elice?는 “elic”, “elice”와 매칭됩니다. |
| {n} | n개 | 123, 456 등 세 자릿수와 매칭됩니다. |
| {n, m} | n개 이상, m개 이하 | ```\w{3, 5}```는 알파벳 세 자리에서 다섯 자리의 단어와 매칭됩니다. |
| {n,} | n개 이상 | ```a{4,}```는 a가 최소 4개 이상 연속된 경우에 매칭됩니다. |

> 수량자의 특성 : 가장 긴 문자열과 매칭하려는 특성이 있다. 이를 **?** 문자를 수량자 뒤에 붙여 탐욕성을 제한할 수 있다.
- ? 문자는 *? 뿐만 아니라 ```+?, ??, {n,}?, {n,m}?``` 등과 같이 사용할 수도 있다.
- 이를 통해 수량자의 원래 특성과는 반대로 가능한 한 최소한의 수량과 매칭되도록 한다.
    - 예 
    ```
    import re

    '''
    아래에 정규표현식을 직접 입력해보세요!
    '''

    text = "<html><head><Title>제목</head></html>"

    p1 = "<.*>"
    p2 = "<.*?>"         #정규표현식을 이용해보세요.

    m1 = re.findall(p1, text)
    m2 = re.findall(p2, text)

    print("m1 결과 : ", m1)
    print("m2 결과 : ", m2)
    ```
    > m1 결과 :  ```['<html><head><Title>제목</head></html>']```, m2 결과 :  ```['<html>', '<head>', '<Title>', '</head>', '</html>']```

